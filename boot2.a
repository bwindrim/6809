; boot2.a - second-stage bootloader for 6809 board
;
			org	$FF00   	; boot2's code+stack goes in last 256 bytes of RAM
			lds	#$FFF0  	; stack grows downward from the very top of RAM, below the hardware vectors
			lda	#$FE		; point the DP reg to the I/O register space
			exg	a,dp
			lda	#0			; set DDRA to input
			sta	<3			; $FE03 is the 6522's DDRA (Port A Data Direction Register)
			lda	#$FF		; set DDRB to output
			sta	<2			; $FE02 is the 6522's DDRB (Port B Data Direction Register)
			lda	#1			; set ACR to 00000001 Timed interrupt, PB7 disabled, timed interrupt, shifter disabled, PB latch disable, PA latch enable
			sta	<$0B		; $FE0B is the 6522's ACR (Auxiliary Control Register)
			lda	#$AA		; set PCR to 10101010 CB2 pulse output, CB1 -ve edge, CA2 pulse ouput, CA1 -ve edge
			sta	<$0C		; $FE0C is the 6522's PCR (Program Control Register)
wait:		bsr getbyte		; wait for the prefix byte
			cmpb	#$AA
			bne	wait
dload:		bsr	getword		; get the load address
			exg	d,x			; move it to X
			bsr	getword		; get the length
			exg	d,y			; move it to Y
			leay	1,y		; increment the length to allow for the initial decrement & test (length may be zero)
byteloop:	leay	-1,y	; decrement the length count
			beq	exit		; if Y is zero then we're done reading bytes
			bsr	getbyte		; get the next byte
			stb	,x+			; store it in memory
			bra	byteloop
exit:		bsr	getword		; get the exec address
			exg	d,pc		; transfer execution to the exec address
getword:	lda	<$0D		; load A from IFR
			anda #2			; test CA1 (Port A Data Ready) flag
			beq	getword		; loop if no data ready
			lda	<1			; load A from IRA
			sta	<0			; store A to ORB (blind echo, no handshaking)
			; fall through
getbyte:	ldb	<$0D		; load A from IFR
			andb	#2		; test CA1 (Port A Data Ready) flag
			beq	getbyte		; loop if no data ready
			ldb	<1			; load B from IRA
			stb	<0			; store B to ORB (blind echo, no handshaking)
			rts				; return from subroutine
