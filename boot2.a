; boot2.a - second-stage bootloader for 6809 board
;
			include			"globals.i"
			include			"via6522.i"

			org	$FF00   	; boot2's code+stack goes in last 256 bytes of RAM

			lds	#g_base  	; stack grows downward from near the very top of RAM, below the 6809 (HW) and 6522 (SW) vectors

			lda	#0			; set DDRA and DDRB to input
			sta	ddra		; set Port A Data Direction Register to input
			sta	ddrb		; set Port B Data Direction Register to input
			lda	#@00000001	; set ACR to: timer interrupt, PB7 disabled, shifter disabled, PB latch disable, PA latch enable
			sta	acr			; set Auxiliary Control Register
			lda	#@00001000	; set PCR to: CB2 input -ve edge, CB1 -ve edge, CA2 handshake output, CA1 -ve edge
			sta	pcr			; set Program Control Register

			ldx	#$FE00		; One beyond the end of RAM,
			stx	g_memtop;	; this will be the default stacktop for programs
			
restart:
wait:		bsr getbyte		; wait for the download prefix byte
			cmpb #$AA
			bne	wait

			; We've got the prefix byte, start download
dload:		bsr	getword		; get the load address
			tfr	d,x			; move it to X
			cmpd	#$F000  ; if load address is in high memory
			blo low_mem
			std g_memtop 	; set new stacktop for high-mem programs
low_mem:					; fall through to read the length and data
			bsr	getword		; get the length
			tfr	d,y			; move it to Y
			leay	1,y		; increment the length to allow for the initial decrement & test (length may be zero)
byteloop:	leay	-1,y	; decrement the length count
			beq	exit		; if Y is zero then we're done reading bytes
			bsr	getbyte		; get the next byte
			stb	,x+			; store it in memory
			sbra byteloop

exit:		ldx	#restart	; restart address of boot2 code
			pshs X			; push the address onto the stack
			bsr	getword		; get the exec address
			pshs a
			lda ifr			; it seems we need to read IFR to complete the port A handshake
			puls a
			exg	d,pc		; transfer execution to the exec address

getword:	lda	ifr			; load A from IFR
			anda #2			; test CA1 (Port A Data Ready) flag
			sbeq getword	; loop if no data ready

			lda	porta		; load A from port A input register
			; fall through
getbyte:	ldb	ifr			; load A from IFR
			andb	#2		; test CA1 (Port A Data Ready) flag
			sbeq getbyte	; loop if no data ready

			ldb	porta		; load B from port A input register
			rts				; return from subroutine
