; boot2.a - second-stage bootloader for 6809 board
;
			include			"via6522.i"
			
			org	$FF00   	; boot2's code+stack goes in last 256 bytes of RAM

			lds	#$FFF0  	; stack grows downward from near the very top of RAM, below the hardware vectors

			lda	#0			; set DDRA and DDRB to input
			sta	ddra		; set Port A Data Direction Register to input
			sta	ddrb		; set Port B Data Direction Register to input
			lda	#1			; set ACR to 00000001 (timer interrupt, PB7 disabled, shifter disabled, PB latch disable, PA latch enable)
			sta	acr			; set Auxiliary Control Register
			lda	#$08		; set PCR to 00001000 (CB2 input -ve edge, CB1 -ve edge, CA2 handshake output, CA1 -ve edge)
			sta	pcr			; set Program Control Register
restart:
wait:		bsr getbyte		; wait for the download prefix byte
			cmpb #$AA
			bne	wait

			; We've got the prefix byte, start download
dload:		bsr	getword		; get the load address
			exg	d,x			; move it to X
			bsr	getword		; get the length
			exg	d,y			; move it to Y
			leay	1,y		; increment the length to allow for the initial decrement & test (length may be zero)
byteloop:	leay	-1,y	; decrement the length count
			beq	exit		; if Y is zero then we're done reading bytes
			bsr	getbyte		; get the next byte
			stb	,x+			; store it in memory
			sbra byteloop

exit:		ldx	#restart	; restart address of boot2 code
			pshs X			; push the address onto the stack
			bsr	getword		; get the exec address
			pshs a
			lda ifr			; it seems we need to read IFR to complete the port A handshake
			puls a
			exg	d,pc		; transfer execution to the exec address

getword:	lda	ifr			; load A from IFR
			anda #2			; test CA1 (Port A Data Ready) flag
			sbeq getword	; loop if no data ready

			lda	porta		; load A from port A input register
			; fall through
getbyte:	ldb	ifr			; load A from IFR
			andb	#2		; test CA1 (Port A Data Ready) flag
			sbeq getbyte	; loop if no data ready

			ldb	porta		; load B from port A input register
			rts				; return from subroutine
